Legacy projects

We have 2 shared branches, and we tag commits with version numbers on master to mark that commit for release.

Standard workflow:

1. Branch off uat to a new feature or bugfix branch (e.g. feature/OORD-1234 or bugfix/OORD-1235).
2. Make changes and commit frequently to your feature branch.
3. At the start of day/frequently *pull* uat and *rebase* your branch onto it.
    1. Resolve merge conflicts if there are any.
4. Create a PR from your branch to uat.
    1. Test your changes! The tester (Ronald) will only test *after* the PR is merged into uat, so you need to be as sure as possible that your code is functional and bug free before it is merged.
5. Demo your changes to another developer and/or tester - testing against the acceptance criteria on the ticket.
6. After PR is reviewed and any rework done, *squash and merge* it to uat.
    1. Squashing is done so that all your similar code is grouped together into a single commit with a good description and commit message, making it easier to see when changes were made and reducing the number of non-helpful commit messages like “OORD-123 minor changes” or “OORD-123 changes from PR”, as well as removing any intermediate commits where there may have been private keys/passwords committed accidentally.
7. Tester will test against acceptance criteria of the ticket.
8. When uat is in a releasable state (all tickets tested) then a PR from uat to master will be made, bringing across all changes from uat to master.
9. Tester will test.
10. When a release is ready, create a new tag and a new release on GitHub, which will cause an automatic deployment.

Hotfix workflow (making changes directly to prod without deploying uat changes):

1. Branch off master to a new hotfix branch (e.g. hotfix/OORD-1236).
2. Make changes and commit frequently to your hotfix branch.
3. Create a PR from your branch to master
4. Demo changes to developer and tester
5. Squash and merge to master.
6. Create a PR from master to uat to bring your changes back to the general branch.
    1. This should be reviewed but unless there’s conflicts with changes on uat it is unlikely there will be issues.
7. Tester will test on master
8. Create a new tag and a new release on GitHub, which will cause an automatic deployment.